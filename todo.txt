тесты написать 
----------
чекать каждую ссылку на статус мало ли переименуют еще
только на статус без тела
----------
записывать результат фетчинга в файл и проверять нет ли там таких постов
---
items: vec![BiorxivPageStructItem::new(); 30],
whats strange what only 30...weird
-------
по сути как можно избавиться от tokio
-----
rename some local variables in functions
------
service for date/time checking and executing arxiv for example one time per week and check of server restarted in this timestamp
-------
делать хеш от поста и отправлять хеши постов с клиента на сервер чтобы сервер видел отправлял ли уже эти посты или нет
----------------------
в reach_provider вместо полного запроса на тело изменить ток на запрос статуса типо пинга
---------
запихнуть в enum тест\статус код
-----------
проблема еще в том что он дожидается фетча ввсех ссылок. не над так
----------
организация перезапуска фетча ссылок только для тех которые вернули эррор
------
проблема с основной ссылкой архива
-------
 // `iter()` for vecs yields `&i32`.
    let mut iter = vec1.iter();
    // `into_iter()` for vecs yields `i32`.
    let mut into_iter = vec2.into_iter();

    // `iter()` for vecs yields `&i32`, and we want to reference one of its
    // items, so we have to destructure `&&i32` to `i32`
    println!("Find 2 in vec1: {:?}", iter     .find(|&&x| x == 2));
    // `into_iter()` for vecs yields `i32`, and we want to reference one of
    // its items, so we have to destructure `&i32` to `i32`
    println!("Find 2 in vec2: {:?}", into_iter.find(| &x| x == 2));
--------------
let slice: &[u8] = &b;
                let converted_str = str::from_utf8(&slice).unwrap();
                let mut dots_unfiltered_str = converted_str.to_string();
                dots_unfiltered_str.remove(0); //ОЧЕНЬ ВАЖНАЯ СТРОЧКА. НУЖНО УДАЛИТЬ ПЕРВУЮ ЧАСТЬ ЧТОБЫ ФАЙЛ ПРАВИЛЬНО СЧИТАЛСЯ
 ----------------
 extern crate rayon;

use rayon::prelude::*;

fn main() {
    let mut arr = [0, 7, 9, 11];
    arr.par_iter_mut().for_each(|p| *p -= 1);
    println!("{:?}", arr);
}
--------------------
2 302 кода чего ????
---------------------
заменить цикл for на итераторы?
-----------
принты щас не оч корректные на счет цвета
---------------
 reqwest::StatusCode::REQUEST_TIMEOUT рефетч сделать
 -------------
 подобрать функцию которая из стринги делает сейвовый путь заменяя символы
 -------------
 избавиться от всех русскоязычных комментариев
 -------------
 split().map()
 вместо find(<item></item>)
 -------------
 if size of working dir > 100mb then remove all containg
 -----------------
 must be not only 1 str but many - twitter and many nitters
---------------------
https://doc.rust-lang.org/std/primitive.i32.html#method.checked_add
переписать места в которых мб есть переполнение буфера
---------------------
add everywhere explicit types
--------------------
error had .description method 0_o
-----------------
std::stringify
-----------------
std::str::SplitN
-------------
providers statistics in files. if 3 time provider is inactive then do not fetch him next time then next two times...
------------
hashmaps into vecs
------------
twitter errors:
builder error: Too many open files (os error 24)

error sending request for url (https://nitter.cattube.org/_baku89/rss): error trying to connect: dns error: Too many open files (os error 24)

error sending request for url (https://tweet.lambda.dance/_CPResearch_/rss): error trying to connect: tcp open error: Too many open files (os error 24)

error sending request for url (https://nitter.40two.app/_davideast/rss): operation timed out

404 Not Found - CAUSE
This account's tweets are protected.
Only confirmed followers have access to @_KudoHiroyuki's tweets.

429 Too Many Requests
-----------
futures in some cases instead of threads
-----------
thread pool
-----------
do something with that 
pub async fn check_new_posts_threads_parts() {
    let mut threads_vec = Vec::with_capacity(4); arxiv biorxiv medrxiv twitter reddit ...
-----------
&str instead of String everywhere if possible
-----------
'static remove if possible or maybe add if its better 
-----------
ensure! macros
----------
let _ = join_all(vec_of_write_into_files_futures).await; //todo: add state of success/unsuccess
-----------
if let Ok(something) = something.lock() {}
instead of 
something.lock().unwrap();
----------
RES.STATUS: 521 <unknown status code>
----------
operation timed out print time elapsed
----------
github newsfeed
----------
redo fetch link cuz method not allowed error error
------------------
write a test and run before commit to check if i for some reason have user data in config
------------------
let mut threads_vec = Vec::with_capacity(6  thisssss);
implement that with config params 
------------------
Rc<RefCell<Data>>
Rc::new(<RefCell::new(Data { value: 42}))
------------------
db for provider links
------------------
let wrong_cases_thread = thread::spawn(move || {
refetch logic
-------------------
block_on(rss_async_write_fetch_error_logs_into_files_wrapper(
                provider_kind,
                enable_prints,
                // enable_warning_prints: bool,
                enable_error_prints,
                enable_time_measurement,
                some_error_posts,
                warning_logs_directory_name,
            ));
move this code into upper tree positions - no need no waiting for writing files