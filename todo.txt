чекать каждую ссылку на статус мало ли переименуют еще
только на статус без тела
----------
записывать результат фетчинга в файл и проверять нет ли там таких постов
---
items: vec![BiorxivPageStructItem::new(); 30],
whats strange what only 30...weird
-----
rename some local variables in functions
------
service for date/time checking and executing arxiv for example one time per week and check of server restarted in this timestamp
-------
делать хеш от поста и отправлять хеши постов с клиента на сервер чтобы сервер видел отправлял ли уже эти посты или нет
----------------------
в reach_provider вместо полного запроса на тело изменить ток на запрос статуса типо пинга
---------
запихнуть в enum тест\статус код
-----------
проблема еще в том что он дожидается фетча ввсех ссылок. не над так
----------
организация перезапуска фетча ссылок только для тех которые вернули эррор
------
проблема с основной ссылкой архива
-------
 // `iter()` for vecs yields `&i32`.
    let mut iter = vec1.iter();
    // `into_iter()` for vecs yields `i32`.
    let mut into_iter = vec2.into_iter();

    // `iter()` for vecs yields `&i32`, and we want to reference one of its
    // items, so we have to destructure `&&i32` to `i32`
    println!("Find 2 in vec1: {:?}", iter     .find(|&&x| x == 2));
    // `into_iter()` for vecs yields `i32`, and we want to reference one of
    // its items, so we have to destructure `&i32` to `i32`
    println!("Find 2 in vec2: {:?}", into_iter.find(| &x| x == 2));
--------------
let slice: &[u8] = &b;
                let converted_str = str::from_utf8(&slice).unwrap();
                let mut dots_unfiltered_str = converted_str.to_string();
                dots_unfiltered_str.remove(0); //ОЧЕНЬ ВАЖНАЯ СТРОЧКА. НУЖНО УДАЛИТЬ ПЕРВУЮ ЧАСТЬ ЧТОБЫ ФАЙЛ ПРАВИЛЬНО СЧИТАЛСЯ
 ----------------
 extern crate rayon;

use rayon::prelude::*;

fn main() {
    let mut arr = [0, 7, 9, 11];
    arr.par_iter_mut().for_each(|p| *p -= 1);
    println!("{:?}", arr);
}
--------------------
2 302 кода чего ????
---------------------
заменить цикл for на итераторы?
-----------
принты щас не оч корректные на счет цвета
---------------
 reqwest::StatusCode::REQUEST_TIMEOUT рефетч сделать
 -------------
 подобрать функцию которая из стринги делает сейвовый путь заменяя символы
 -------------
 избавиться от всех русскоязычных комментариев
 -------------
 split().map()
 вместо find(<item></item>)
 -------------
 if size of working dir > 100mb then remove all containg
 -----------------
 must be not only 1 str but many - twitter and many nitters
---------------------
https://doc.rust-lang.org/std/primitive.i32.html#method.checked_add
переписать места в которых мб есть переполнение буфера
---------------------
add everywhere explicit types
--------------------
error had .description method 0_o
-----------------
std::stringify
-----------------
std::str::SplitN
-------------
providers statistics in files. if 3 time provider is inactive then do not fetch him next time then next two times...
------------
hashmaps into vecs
------------
twitter errors:
builder error: Too many open files (os error 24)

error sending request for url (https://nitter.cattube.org/_baku89/rss): error trying to connect: dns error: Too many open files (os error 24)

error sending request for url (https://tweet.lambda.dance/_CPResearch_/rss): error trying to connect: tcp open error: Too many open files (os error 24)

error sending request for url (https://nitter.40two.app/_davideast/rss): operation timed out

404 Not Found - CAUSE
This account's tweets are protected.
Only confirmed followers have access to @_KudoHiroyuki's tweets.

429 Too Many Requests
-----------
futures in some cases instead of threads
-----------
thread pool
-----------
do something with that 
pub async fn check_new_posts_threads_parts() {
    let mut threads_vec = Vec::with_capacity(4); arxiv biorxiv medrxiv twitter reddit ...
-----------
&str instead of String everywhere if possible
-----------
'static remove if possible or maybe add if its better 
-----------
ensure! macros
----------
let _ = join_all(vec_of_write_into_files_futures).await; //todo: add state of success/unsuccess
-----------
if let Ok(something) = something.lock() {}
instead of 
something.lock().unwrap();
----------
RES.STATUS: 521 <unknown status code>
----------
operation timed out print time elapsed
----------
github newsfeed
----------
redo fetch link cuz method not allowed error error
------------------
write a test and run before commit to check if i for some reason have user data in config
------------------
let mut threads_vec = Vec::with_capacity(6  thisssss);
implement that with config params 
------------------
Rc<RefCell<Data>>
Rc::new(<RefCell::new(Data { value: 42}))
------------------
db for provider links
------------------
let wrong_cases_thread = thread::spawn(move || {
refetch logic
-------------------
block_on(rss_async_write_fetch_error_logs_into_files_wrapper(
                provider_kind,
                enable_prints,
                // enable_warning_prints: bool,
                enable_error_prints,
                enable_time_measurement,
                some_error_posts,
                warning_logs_directory_name,
            ));
move this code into upper tree positions - no need no waiting for writing files
--------------------
write logs into file in different service
--------------------
maybe cast struct into common rss with option type with fields for all providers//bad idea
--------------------
twitter bug
----------------------------
create big xml/json file to test parsing speed
----------------------------
add write logs into dir if provider doesnt respond to request 
there is no point for that before adding database
-------------------------------
generate_biorxiv_hashmap_links and others rename this - remove hashmap
-------------------------------
rss_struct.entries[count].content.clone(), //todo: content is html now, need parsing
--------------------
thread pool with this let cpus = num_cpus::get();
--------------------
find out why constants which used in tests looks like unused
--------------------
We can specify part of a test name, and any test whose name matches that value will be run. For example, because two of our tests’ names contain add, we can run those two by running cargo test add
its solution for github actions test running command
--------------------
write some logic and flag what choose between config values and in code constants for more efficient production variant 
--------------------
google some style guide variable naming for project(parsing espesially) and rename variables
--------------------
[dependencies] and [dev-dependencies] 
--------------------
pub const PROJECT_MODE: &str = "Development";//later as ENV variable only
----------------------------
impl UserCredentialsStruct {
    pub fn new() -> Result<Self, ConfigError> {
        maybe add different user logic later ?
----------------------------
move get config and user credentials into config
----------------------------
todo: add medium
----------------------------
cannot do cargo build while docker build with this library = { path = "./library" }
----------------------------
parsing providers posts tests
----------------------------
command for run not a cargo run but cd libs/tests_lib && cargo test local && cd .. && cd .. && cargo run
----------------------------
why hashmap['key'] do not return Result ?????7
----------------------------
server what running web tests every hour like http requests and get valid data or not
